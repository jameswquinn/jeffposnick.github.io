<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>thirty-four</title>
    <description>thirty-four is crafted with love in Brooklyn, by Jeff Posnick.</description>
    <link>https://jeffy.info</link>
    <atom:link href="https://jeffy.info/feed.xml" rel="self" type="application/atom+xml"/>
    <pubDate>Sat, 11 Feb 2017 12:57:01 -0500</pubDate>
    <lastBuildDate>Sat, 11 Feb 2017 12:57:01 -0500</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>Offline-first for Your Templated Site (Part Two)</title>
        <description>&lt;p&gt;&lt;em&gt;This is the second part of a planned three-part series.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Part &lt;a href=&quot;https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html&quot;&gt;one&lt;/a&gt; covered some basic terminology an setup that’s referenced throughout this post.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Part three will dive into a specific service worker implementation that can be
used to provide an offline-first experience for a Jekyll-based site.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Folks who can’t wait for part three are welcome to check out the
&lt;a href=&quot;https://jeffy.info&quot;&gt;https://jeffy.info&lt;/a&gt;
service worker &lt;a href=&quot;https://github.com/jeffposnick/jeffposnick.github.io/tree/work/src&quot;&gt;implementation&lt;/a&gt;
ahead of time.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;decisions-decisions&quot;&gt;Decisions, decisions&lt;/h1&gt;

&lt;p&gt;With those preliminary definitions out of the way, we can focus on the question at hand: how do you provide an offline-first experience for your templated site?&lt;/p&gt;

&lt;p&gt;I’m going to outline three different approaches, each with their own benefits and drawbacks. Choosing the right approach requires balancing various tradeoffs, and the aim of this post is to walk through the plusses and minuses of each strategies, so that you can make an informed decision about what works best for your site.&lt;/p&gt;

&lt;h1 id=&quot;option-1-cache-entire-html-documents&quot;&gt;Option 1: Cache entire HTML documents&lt;/h1&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;This approach uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage&quot;&gt;Cache Storage API&lt;/a&gt; to keep a copy of the fully rendered HTML document that corresponds to each URL. The documents might be precached when the service worker is installed, or the caches might be populated via a runtime caching strategy that adds to the cache as users browse from page to page.&lt;/p&gt;

&lt;h2 id=&quot;benefits&quot;&gt;Benefits&lt;/h2&gt;

&lt;h3 id=&quot;service-worker-simplicity&quot;&gt;Service worker simplicity&lt;/h3&gt;

&lt;p&gt;The service worker needed to implement this type of strategy is &lt;em&gt;relatively&lt;/em&gt; straightforward. The &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; handler can check to see whether &lt;code class=&quot;highlighter-rouge&quot;&gt;event.request.mode === 'navigate'&lt;/code&gt;, and if so, use a &lt;a href=&quot;https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate&quot;&gt;stale-while-revalidate strategy&lt;/a&gt; to handle the request for the HTML document.&lt;/p&gt;

&lt;h3 id=&quot;minimal-additional-maintenance&quot;&gt;Minimal additional maintenance&lt;/h3&gt;

&lt;p&gt;While you need to create and deploy a service worker script, there isn’t anything additional that you need to deploy and maintain. The same HTML documents that you’ve previously generated and deployed can continue to be served the same way.&lt;/p&gt;

&lt;h3 id=&quot;multiple-layout-template-flexibility&quot;&gt;Multiple layout template flexibility&lt;/h3&gt;

&lt;p&gt;Instead of a single layout template, some sites might find themselves using multiple layouts to generate the final HTML. For example, all documents served from the URL prefix &lt;code class=&quot;highlighter-rouge&quot;&gt;/blog/&lt;/code&gt; might use &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_layout.tmpl&lt;/code&gt;, while all documents served from under &lt;code class=&quot;highlighter-rouge&quot;&gt;/news/&lt;/code&gt; might use &lt;code class=&quot;highlighter-rouge&quot;&gt;news_layout.tmpl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Because the complete HTML documents are stored and retrieved from the cache, the service worker doesn’t need any special knowledge about which underlying layout was used to generate the page.&lt;/p&gt;

&lt;p&gt;That also means that a subset of URLs that aren’t generated via templating at all—perhaps a site’s &lt;code class=&quot;highlighter-rouge&quot;&gt;about.html&lt;/code&gt; page, for instance—can be handled via the same logic used for all the other URLs.&lt;/p&gt;

&lt;h2 id=&quot;drawbacks&quot;&gt;Drawbacks&lt;/h2&gt;

&lt;h3 id=&quot;cache-overhead&quot;&gt;Cache overhead&lt;/h3&gt;

&lt;p&gt;Let’s return to our diagram of the “&lt;a href=&quot;https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html#the-process-that-smushes-together-the-templates-and-the-contents-and-outputs-a-final-html-document&quot;&gt;smushening&lt;/a&gt;” process, which takes our template, combines it with each of our individual content files, and then results in a complete HTML document:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2016-11-02/smushening.svg&quot; alt=&quot;A layout + content = final pages&quot; class=&quot;half-width&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_layout.tmpl&lt;/code&gt; file is used to generate each of the final HTML documents, and that means that the size of each HTML file is roughly equal to the size of the template file plus the size of the page-specific content.&lt;/p&gt;

&lt;p&gt;If your template file is &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; bytes, and your have &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; output HTML files, you’re incurring &lt;code class=&quot;highlighter-rouge&quot;&gt;X * N&lt;/code&gt; bytes of duplicated cache contents, due to size of the templated portion of each final HTML document.&lt;/p&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; is a fairly small number (a template file of less than 1kb is common) and/or &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; is small (say, only a few dozen unique HTML files), then the amount of cache storage used is negligible. However, if you’re using larger templates, or you know that you have hundreds or even thousands of HTML pages that a user might have cached, the overhead can start impacting those users who are storage constrained.&lt;/p&gt;

&lt;h3 id=&quot;messy-updates&quot;&gt;Messy updates&lt;/h3&gt;

&lt;p&gt;While the cache overhead isn’t a showstopper, the compromises involved in updating previously cached content is more of a concern. Let’s assume that we have &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.html&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bar.html&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;foo_bar.html&lt;/code&gt; HTML files stored in our cache.&lt;/p&gt;

&lt;p&gt;If we were to make some updates to the &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.md&lt;/code&gt; content that’s used to populate &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.html&lt;/code&gt;, our update strategy is to ensure that &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.html&lt;/code&gt; eventually gets refetched from the network. This might happen via a normal &lt;a href=&quot;https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate&quot;&gt;stale-while-revalidate&lt;/a&gt; flow, in which case the new content will only be available the &lt;em&gt;second&lt;/em&gt; time a user revisits the page. Or it might happen by explicitly purging the existing &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.html&lt;/code&gt; entry from the cache ahead of time, making the new content available for the &lt;em&gt;next&lt;/em&gt; visit.&lt;/p&gt;

&lt;p&gt;But what if we make an update to &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_layout.tmpl&lt;/code&gt;? Maybe we’ve changed our navigation bar, or updated some header text. The impact of this change ripples beyond a single cache entry—&lt;em&gt;all&lt;/em&gt; of our cached HTML files that depended on &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_layout.tmpl&lt;/code&gt; are now out of date.&lt;/p&gt;

&lt;p&gt;We have the same options for dealing with this as before: let a stale-while-revalidate caching strategy gradually update the stale entries as users revisit pages, or proactively purge the out of date cache content, which in this case could mean invalidating our entire cache. There are serious downsides to each approach, though.&lt;/p&gt;

&lt;p&gt;If we rely on a &lt;a href=&quot;https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate&quot;&gt;stale-while-revalidate&lt;/a&gt; runtime caching strategy to gradually update our cache, users will see inconsistencies across page navigations. The changes made to &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_layout.tmpl&lt;/code&gt; will only take effect after they revisit pages multiple times. If a user returns to a previously cached page months later, they’ll still see your old layout, which can be jarring after they’ve gotten accustomed to seeing layout changes on fresh pages.&lt;/p&gt;

&lt;p&gt;To avoid jarring your users, proactively purging &lt;em&gt;all&lt;/em&gt; cached HTML that relies on a modified template is arguably the best approach. But now you’re faced with another tradeoff: the performance and offline benefits of caching are diminished if users’ caches are invalidated frequently. The effort that you put into implementing a caching strategy is wasted if you have to throw your entire cache away due to even small updates to your site’s layout.&lt;/p&gt;

&lt;h2 id=&quot;real-world-examples&quot;&gt;Real-world examples&lt;/h2&gt;

&lt;p&gt;A number of my colleagues, including &lt;a href=&quot;https://gauntface.com/blog/&quot;&gt;Matt Gaunt&lt;/a&gt;, &lt;a href=&quot;https://paul.kinlan.me&quot;&gt;Paul Kinlan&lt;/a&gt;, and &lt;a href=&quot;https://sgom.es/&quot;&gt;Sérgio Gomes&lt;/a&gt;, are using this option for their blogs.&lt;/p&gt;

&lt;h1 id=&quot;option-2-use-an-application-shell-architecture&quot;&gt;Option 2: Use an Application Shell architecture&lt;/h1&gt;

&lt;h2 id=&quot;how-it-works-1&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;The Application Shell architecture is covered in great detail in &lt;a href=&quot;https://developers.google.com/web/fundamentals/architecture/app-shell&quot;&gt;this article&lt;/a&gt; by Addy Osmani and Matt Gaunt. My talk from the 2015 Chrome Dev Summit also covers similar ground, for those who prefer video:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/jCKZDTtUA2A&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;While the Application Shell architecture is often talked about in reference to “web apps,” it’s definitely applicable to the types of templated “content sites” that we’re talking about here.&lt;/p&gt;

&lt;p&gt;The general approach is to repurpose your existing page structure, i.e. what’s defined in your &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_layout.tmpl&lt;/code&gt; template, to serve as your Application Shell. This should be a valid, standalone HTML file (let’s call it &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt;) that includes a placeholder element that the dynamic content gets inserted into at runtime, via client-side templating.&lt;/p&gt;

&lt;p&gt;The dynamic content could be the same raw content sources—&lt;code class=&quot;highlighter-rouge&quot;&gt;foo.md&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bar.md&lt;/code&gt;, etc.—in which case the Application Shell’s JavaScript would need to &lt;a href=&quot;https://github.com/markdown-it/markdown-it&quot;&gt;convert&lt;/a&gt; the content to HTML at runtime, prior to inserting it into the DOM. Or you might go through an additional step and convert the raw content into HTML snippets via a server-side process, in which case the content snippets can be inserted directly into the DOM at runtime.&lt;/p&gt;

&lt;p&gt;You can use either a precaching or a runtime caching strategy like &lt;a href=&quot;https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate&quot;&gt;stale-while-revalidate&lt;/a&gt; to keep both &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt; and the underlying content up to date, while still serving them cache-first.&lt;/p&gt;

&lt;h2 id=&quot;benefits-1&quot;&gt;Benefits&lt;/h2&gt;

&lt;h3 id=&quot;clean-updates&quot;&gt;Clean updates&lt;/h3&gt;

&lt;p&gt;Your structural HTML (&lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt;) and your content are cached independently, so when you make changes to a page’s content or to your site’s layout elements, cache invalidation is simple and efficient. The only cache entries that need to be updated is either the content itself, or the entry for &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt;. If &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt; does get updated, then the updates will immediately apply to all pages on your site that share that Application Shell, ensuring that your site looks the same as the user moves from page to page. You eliminate the risk of a months-old cached page being shown, jarring a user with an inconsistent layout.&lt;/p&gt;

&lt;h3 id=&quot;low-overhead-precaching&quot;&gt;Low-overhead precaching&lt;/h3&gt;

&lt;p&gt;Using this architecture opens the door to precaching more of your site’s content. Larger precache coverage means that pages a user hasn’t previously navigated to will still work offline and load quickly. There are two reasons why aggressive precaching is more viable:&lt;/p&gt;

&lt;p&gt;First, each piece of content can be cached as-is, independent of the App Shell’s HTML. The &lt;a href=&quot;#cache-overhead&quot;&gt;cache overhead&lt;/a&gt; concerns with full-page caching don’t apply, and as a developer, you don’t have to worry about wasting as much bandwidth and space as you would if you were precaching full HTML documents.&lt;/p&gt;

&lt;p&gt;Second, and more importantly, &lt;a href=&quot;#clean-updates&quot;&gt;clean updates&lt;/a&gt; mean that you’re much less likely to end up throwing away data once it’s been precached. The only time you’d have to expire and redownload precached content is if that specific content is updated. A substantial precache payload is makes much less sense if you know that it will all end up expired each time you tweak your site’s template.&lt;/p&gt;

&lt;h2 id=&quot;drawbacks-1&quot;&gt;Drawbacks&lt;/h2&gt;

&lt;h3 id=&quot;routing-logic-in-your-service-worker&quot;&gt;Routing logic in your service worker&lt;/h3&gt;

&lt;p&gt;In the Application Shell model, your service worker needs to have special logic in place to handle &lt;a href=&quot;https://html.spec.whatwg.org/#navigating-across-documents&quot;&gt;navigation requests&lt;/a&gt;. While the incoming request might be for a URL like &lt;code class=&quot;highlighter-rouge&quot;&gt;https://example.com/2016/12/foo.html&lt;/code&gt;, your service worker needs to respond with your cached &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt; document, not with &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.html&lt;/code&gt; (which won’t be cached in this model). Your Application Shell is then responsible for performing client-side templating and inserting the correct content into the DOM, based on whatever the request URL is.&lt;/p&gt;

&lt;p&gt;This works fine when you only have one common layout, defined in &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt;, that’s shared by all the pages on your site. But if there’s a subset of pages on your site that use completely different layouts, like &lt;code class=&quot;highlighter-rouge&quot;&gt;https://example.com/about.html&lt;/code&gt;, your service worker needs to know &lt;em&gt;not&lt;/em&gt; to respond to those navigation requests with &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your service worker is now an HTTP router, examining incoming navigations requests and serving the right type of response for each URL. If there’s a simple URL pattern that can be used to match all of the requests that can be handled with the &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt; layout, then you’re in good shape—something like the following might suffice:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.addEventListener('fetch', event =&amp;gt; {
  const yearMonthPrefix = new RegExp('/\d{4}/\d{2}/');
  if (event.request.mode === 'navigation') {
    if (event.request.url.matches(yearMonthPrefix)) {
      // Use the Application Shell to handle requests like
      // https://example.com/2016/12/foo.html
      event.respondWith(caches.match('shell.html'));
    } else {
      // Use an appropriate runtime caching strategy, like
      // stale-while-revalidate, to handle requests like
      // https://example.com/about.html.
    }
  } else {
    // Use an appropriate runtime caching strategy for
    // non-navigation requests, like requests for
    // images or other resources.
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But if you don’t have that level of consistency in your URL structure, of if there’s a subset of pages that fall under the &lt;code class=&quot;highlighter-rouge&quot;&gt;/year/month/&lt;/code&gt; prefix but use a completely different template, accurately reflecting that routing logic in your service worker gets much trickier and you need to construct a bespoke solution.&lt;/p&gt;

&lt;h3 id=&quot;duplicated-effort&quot;&gt;Duplicated effort&lt;/h3&gt;

&lt;p&gt;If you’ve already got a templated site, adopting the Application Shell architecture will usually mean duplicating pieces of your existing infrastructure. You need to take your &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_layout.tmpl&lt;/code&gt; and convert it into a &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt; file, adding to it the necessary client-side templating logic to populate your shell.&lt;/p&gt;

&lt;p&gt;You might also need to add in a build step that takes original Markdown sources and converts them to HTML snippets, in in lieu of having to perform that Markdown conversion inside your Application Shell.&lt;/p&gt;

&lt;p&gt;Finally, if your site relies on any sort of custom routing or templating rules that are implemented server-side, that routing logic needs to be moved into your service worker, as explained in the &lt;a href=&quot;#routing-logic-in-your-service-worker&quot;&gt;previous section&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This duplication means that there are more opportunities for pieces of your site to get out of sync. If you make changes to your &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_layout.tmpl&lt;/code&gt;, but the corresponding changes aren’t made to &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt;, then browsers which lack service worker support will see one thing, while browsers that have a service worker responding with your Application Shell will see something else. Similar issues could arise if your routing rules need tweaking—they could potentially need to be changed in &lt;em&gt;three&lt;/em&gt; places (server-side, client-side in &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;SPA-style&lt;/a&gt; JavaScript, and client-side in service worker JavaScript) depending on how complicated your routing needs are. Trisomorphic routing: it’s actually A Thing!&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;a href=&quot;https://twitter.com/adactioJournal&quot;&gt;@adactioJournal&lt;/a&gt; Shows there are fantastic opportunities, though. I&amp;#39;ve yet to see someone nail &amp;quot;trisomorphic&amp;quot; routing (server + JS + SW).&lt;/p&gt;&amp;mdash; Nolan Lawson (@nolanlawson) &lt;a href=&quot;https://twitter.com/nolanlawson/status/735469605238509569&quot;&gt;May 25, 2016&lt;/a&gt;&lt;/blockquote&gt;

&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;Proper automation of your build process can ensure that the overhead and risk of duplicated pieces getting out of sync is minimal, but that’s one more thing to keep track of.&lt;/p&gt;

&lt;h2 id=&quot;real-world-examples-1&quot;&gt;Real-world examples&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://ifixit-pwa.appspot.com/&quot;&gt;iFixit PWA&lt;/a&gt; sample (the &lt;a href=&quot;https://github.com/GoogleChrome/sw-precache/tree/master/app-shell-demo&quot;&gt;source&lt;/a&gt; of which is part of the &lt;a href=&quot;https://github.com/GoogleChrome/sw-precache&quot;&gt;sw-precache project&lt;/a&gt;) is an Application Shell populated with dynamic content from the &lt;a href=&quot;https://www.ifixit.com/api/2.0/doc/&quot;&gt;iFixit API&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;option-3-service-worker-templating&quot;&gt;Option 3: Service worker templating&lt;/h1&gt;

&lt;h2 id=&quot;how-it-works-2&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;With this approach, you take the logic needed to smush together your templates and content and implement it within your service worker.&lt;/p&gt;

&lt;p&gt;This doesn’t mean that you’d do away with your site’s existing build process, though. You can’t assume that when a user visits your site there’s going to be an active service worker, so you still need to serve complete HTML pages via your normal web server. But when a user returns to your site using a browser that supports service workers, they no longer have to request those complete HTML pages in order to display your site. They should already have your site’s templates cached, and they may or may not have the page’s content cached as well. So, at worst, only a very minimal amount of page-specific content needs to be requested, and at best, your service worker can assemble the complete HTML immediately, without having to go to the network at all.&lt;/p&gt;

&lt;h2 id=&quot;benefits-2&quot;&gt;Benefits&lt;/h2&gt;

&lt;h3 id=&quot;clean-updates-and-low-overhead-precaching&quot;&gt;Clean updates and low-overhead precaching&lt;/h3&gt;

&lt;p&gt;Both the &lt;a href=&quot;#clean-updates&quot;&gt;clean updates&lt;/a&gt; and &lt;a href=&quot;#low-overhead-precaching&quot;&gt;low-overhead precaching&lt;/a&gt; benefits of the App Shell model apply here, as well.&lt;/p&gt;

&lt;h3 id=&quot;no-need-to-adopt-single-page-app-patterns&quot;&gt;No need to adopt Single Page App patterns&lt;/h3&gt;

&lt;p&gt;While the App Shell approach might seem familiar to developers who are familiar with writing client-side JavaScript and using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;Single Page App&lt;/a&gt; (SPA) pattern, not every developer who manages a templated site with be comfortable with that model. You don’t have to write and deploy a SPA when you use the service worker templating option, but you end up with most of the same benefits.&lt;/p&gt;

&lt;p&gt;(Of course, there’s a significant engineering effort required to properly implement service worker templating, but it’s a different kind of effort…)&lt;/p&gt;

&lt;h2 id=&quot;drawbacks-2&quot;&gt;Drawbacks&lt;/h2&gt;

&lt;h3 id=&quot;a-javascript-friendly-templating-system-is-a-must&quot;&gt;A JavaScript-friendly templating system is a must&lt;/h3&gt;

&lt;p&gt;This approach is only viable if you’re using a templating system that has a JavaScript implementation. And because the code will be run inside of a service worker, JavaScript code that requires features specific to the node environment, like filesystem support, won’t work.&lt;/p&gt;

&lt;p&gt;Fortunately, the JavaScript ecosystem is vibrant, and there’s a decent chance that you’d &lt;a href=&quot;https://npms.io/search?q=template&quot;&gt;find&lt;/a&gt; a JavaScript implementation of many templating systems. Running the JavaScript code through &lt;a href=&quot;https://github.com/substack/node-browserify&quot;&gt;browserify&lt;/a&gt; can often smooth over the differences between the node and service worker runtime environments.&lt;/p&gt;

&lt;h3 id=&quot;heavyweight-service-worker-code&quot;&gt;Heavyweight service worker code&lt;/h3&gt;

&lt;p&gt;In order to get your templating system working inside of your service worker, you’ll almost certainly need to bundle in a number of external dependencies. Compared to a svelte service worker that implements a basic runtime caching strategy, you’ll need to transfer more bytes of JavaScript each time your service worker is fetched from the network.&lt;/p&gt;

&lt;p&gt;Your service worker is almost certainly going to spend more time executing code, since the “&lt;a href=&quot;https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html#the-process-that-smushes-together-the-templates-and-the-contents-and-outputs-a-final-html-document&quot;&gt;smushening&lt;/a&gt;” process that would otherwise be done at build-time is effectively run within a user’s browser each time it display a page. The amount of overhead that this adds depends on how efficient your JavaScript templating system is and how powerful each of your users’ devices are.&lt;/p&gt;

&lt;h3 id=&quot;routing-logic-in-your-service-worker-1&quot;&gt;Routing logic in your service worker&lt;/h3&gt;

&lt;p&gt;This was covered in detail in the App Shell’s drawbacks section; the same routing considerations apply here. The main difference is that instead of serving a cached &lt;code class=&quot;highlighter-rouge&quot;&gt;shell.html&lt;/code&gt; file when the route matches, you need to kick off your templating logic when there’s a matching navigation request.&lt;/p&gt;

&lt;h3 id=&quot;duplicated-effort-1&quot;&gt;Duplicated effort&lt;/h3&gt;

&lt;p&gt;This is also similar to the drawback with using an App Shell. Using this approach requires that you continue to run the “&lt;a href=&quot;https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html#the-process-that-smushes-together-the-templates-and-the-contents-and-outputs-a-final-html-document&quot;&gt;smushening&lt;/a&gt;” process like you were previously doing, but then additionally start serving not only the final HTML documents, but also the unprocessed template and content files, since those pieces will need to be fetched and cached by the service worker. You’ll need to make sure that whenever a template or content is updated, both the final HTML as well as the raw files are updated on your server.&lt;/p&gt;

&lt;p&gt;You’ll also probably end up duplicating some of the work that your current build process does to generate metadata about your site. For example, Jekyll maintains it own list of recent posts and uses it to populate the index page for a site. Your service worker needs similar data in order to construct the same page, so writing your own code to &lt;a href=&quot;https://github.com/jeffposnick/jeffposnick.github.io/blob/work/gulpfile.js#L34&quot;&gt;generate&lt;/a&gt; the metadata in a &lt;a href=&quot;https://raw.githubusercontent.com/jeffposnick/jeffposnick.github.io/master/posts.json&quot;&gt;format&lt;/a&gt; that your service worker could consume, and keeping that metadata in sync whenever you update your site, is now required.&lt;/p&gt;

&lt;h2 id=&quot;real-world-examples-2&quot;&gt;Real-world examples&lt;/h2&gt;

&lt;p&gt;My personal blog, &lt;a href=&quot;https://jeffy.info/&quot;&gt;https://jeffy.info/&lt;/a&gt;, is currently using &lt;a href=&quot;https://github.com/jeffposnick/jeffposnick.github.io/tree/work/src&quot;&gt;service worker templating&lt;/a&gt;. We’ll dive into the specifics of how that’s implemented in the next part of this series!&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Jan 2017 17:00:00 -0500</pubDate>
        <link>https://jeffy.info/2017/01/24/offline-first-for-your-templated-site-part-2.html</link>
        <guid isPermaLink="true">https://jeffy.info/2017/01/24/offline-first-for-your-templated-site-part-2.html</guid>
        
        <category>pwa</category>
        
        <category>offline</category>
        
        <category>service-worker</category>
        
        <category>jekyll</category>
        
        <category>app-shell</category>
        
        <category>caching</category>
        
        
      </item>
    
      <item>
        <title>Offline-first for Your Templated Site (Part One)</title>
        <description>&lt;p&gt;&lt;em&gt;This is the first part of a planned three-part series.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Part two will cover different strategies for caching and serving templated sites.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Part three will dive into a specific service worker implementation that can be
used to provide an offline-first experience for a Jekyll-based site.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Folks who can’t wait for part three are welcome to check out the
&lt;a href=&quot;https://jeffy.info&quot;&gt;https://jeffy.info&lt;/a&gt;
service worker &lt;a href=&quot;https://github.com/jeffposnick/jeffposnick.github.io/tree/work/src&quot;&gt;implementation&lt;/a&gt;
ahead of time.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;whats-offline-first&quot;&gt;What’s offline-first?&lt;/h1&gt;

&lt;p&gt;Let’s see if I can get away with just embedding a tweet:&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;…&amp;quot;Offline first&amp;quot; is a serving strategy. Get as far as you can with local data before going to the network.&lt;br /&gt;&lt;br /&gt;(serve-)offline-(content-)first.&lt;/p&gt;&amp;mdash; Jake Archibald (@jaffathecake) &lt;a href=&quot;https://twitter.com/jaffathecake/status/788289680735436800&quot;&gt;October 18, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;That’s offline-first.&lt;/p&gt;

&lt;h1 id=&quot;whats-a-templated-site&quot;&gt;What’s a templated site?&lt;/h1&gt;

&lt;p&gt;What I’m calling a &lt;em&gt;templated site&lt;/em&gt; is built using multiple templates, combined with the actual text, images and other resources that make up the site’s content, spread across multiple pages. The site’s URLs uniquely identify the content specific to a page. The templates provide a structural layout shared across the pages.&lt;/p&gt;

&lt;p&gt;This is all a convoluted way of describing what’s otherwise known as a “content site”, but that’s deliberate: I want to avoid all the baggage that comes along with the “content site” label, especially the implication of what it’s not—a “web app”. What I’m describing are considerations for a particular architectural equation: templates + content = your site. If you’ve got templates, and some source of content, and you mix them together (either ahead of time during a build process, or at runtime on a server), then you’ve got a templated site! If you want to also call it a web app, cool; if you want to call it a content site, or a blog, or a CMS-powered site, that’s totally cool too.&lt;/p&gt;

&lt;p&gt;Since it’s always fun to draw contrasts, if I did have to hold up something in opposition to a templated site, it would be a &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;single page application&lt;/a&gt;. There’s a meaningful difference between the way SPAs handle navigations (using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History&quot;&gt;History API&lt;/a&gt; to rewrite URLs, and swapping content out of an “&lt;a href=&quot;https://developers.google.com/web/updates/2015/11/app-shell&quot;&gt;application shell&lt;/a&gt;” container), and how templated sites handle navigations (as actual &lt;em&gt;&lt;a href=&quot;https://html.spec.whatwg.org/multipage/browsers.html#navigate&quot;&gt;navigations&lt;/a&gt;&lt;/em&gt;, in which the current DOM is torn down, and built up again based on the new HTML). SPAs fill an important role in the web’s ecosystem, and they are the right architecture to use for certain types of projects, but they’re different beasts than templated sites.&lt;/p&gt;

&lt;p&gt;In case it’s not clear from that preamble, what you’re reading now, assuming it’s being read on https://jeffy.info/, is part of a templated site. Blogs, newspapers, and whole host of sites driven drive by a backend &lt;a href=&quot;https://en.wikipedia.org/wiki/Content_management_system&quot;&gt;content management system&lt;/a&gt; are traditionally deployed as templated sites. If you’re reading the syndicated copy of this on https://medium.com/, then I’m going to hazard a guess that the “templated site” label is also appropriate, but I’m not as familiar with how they implement things. &lt;code class=&quot;highlighter-rouge&quot;&gt;¯\_(ツ)_/¯&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;anatomy-of-a-templated-site&quot;&gt;Anatomy of a templated site&lt;/h1&gt;

&lt;p&gt;All right: with what’s hopefully a non-controversial set of a definitions out of the way, let’s take a deeper dive into the different pieces that work together to produce a templated site. I’m going to focus on a specific framework, &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;, which I’m familiar with and that I use on https://jeffy.info/. The general concepts, if not the specific formats used for all the pieces, should apply broadly to other frameworks.&lt;/p&gt;

&lt;h2 id=&quot;templates&quot;&gt;Templates!&lt;/h2&gt;

&lt;p&gt;Yes, templates. Templated sites have templates. Moving along…&lt;/p&gt;

&lt;p&gt;Well, okay, there’s more to explore here. Templates are usually small chunks of HTML that fill a certain structural role on a page—the header, the sidebar, the footer, etc. There’s also likely to be a template that defines the HTML structure for the main bit of a page—the content—and which contains an insertion point where the words are plunked in from the content management system (more on that soon). These various templates are laid out in a… &lt;a href=&quot;http://jekyll.tips/jekyll-casts/layouts/&quot;&gt;layout&lt;/a&gt;, which can be expressed as a template composed of those sub-templates.&lt;/p&gt;

&lt;p&gt;Unfortunately, I lack the visual skills of some of my &lt;a href=&quot;https://jakearchibald.com/2014/offline-cookbook/#on-install-as-a-dependency&quot;&gt;colleagues&lt;/a&gt;, but here’s a rough sketch of what we’re talking about, with the hypothetical smaller templates that work together to form a layout template for blog post:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2016-11-02/blog_layout.svg&quot; alt=&quot;Templates come together to form a blog post layout&quot; class=&quot;half-width&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The interesting bit here is that each of those smaller templates can be tweaked and modified individually, and sometimes (but not always) don’t have to coordinate with each other or with the parent layout. You can imagine a rebranding in which a product name is changed in &lt;code class=&quot;highlighter-rouge&quot;&gt;head.tmpl&lt;/code&gt;, or a copyright year is changed in &lt;code class=&quot;highlighter-rouge&quot;&gt;foot.tmpl&lt;/code&gt;, without that requiring a larger change to any of the other templates or layouts.&lt;/p&gt;

&lt;h2 id=&quot;content&quot;&gt;Content!&lt;/h2&gt;

&lt;p&gt;Next up, let’s assume that we have some content (like: this post) that we want to share with the world. That content might live in a database. It might live in individual files—Jekyll uses individual &lt;a href=&quot;https://jekyllrb.com/docs/posts/&quot;&gt;Markdown files&lt;/a&gt;. It might be accessed as JSON returned from a content management system’s API. The important bits are the idea that there’s a logical separation between the content for one page and the content for another, and the idea that content is independent from the overall page structure that’s used to display it.&lt;/p&gt;

&lt;p&gt;I don’t know how to make diagrams of abstract content interesting, but… here’s a depiction of content for you:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2016-11-02/content.svg&quot; alt=&quot;An abstract representation of content&quot; class=&quot;half-width&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-process-that-smushes-together-the-templates-and-the-contents-and-outputs-a-final-html-document&quot;&gt;The process that smushes together the templates and the contents and outputs a final HTML document!&lt;/h2&gt;

&lt;p&gt;We’ve got some templates that are stitched together to make a layout, and we’ve got some content. What’s left is smushing the layout and the content together to form a unique HTML document corresponding to each piece of source of content.&lt;/p&gt;

&lt;p&gt;The specifics of the smushing vary greatly depending on what framework you’re using. When you know that you have a potentially huge corpus of content (think: the entire archives of a newspaper), you might opt for a framework that smushes on demand, server-side, in response to a request from a client. When you’re dealing with a slightly slimmer corpus (https://jeffy.info/: four posts and counting!), or if you want to avoid running custom code on a server, it can make sense to use a framework that smushes everything ahead of time. The you can serve the final HTML using any run of the mill HTTP server. That’s what the Jekyll framework &lt;a href=&quot;https://jekyllrb.com/docs/usage/&quot;&gt;does&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here’s your requisite diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2016-11-02/smushening.svg&quot; alt=&quot;A layout + content = final pages&quot; class=&quot;half-width&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The complete HTML documents are then displayed by the browser, blissfully unawares of all the behind-the-scenes architecture that was needed to get to this point.&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Nov 2016 13:00:00 -0400</pubDate>
        <link>https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html</link>
        <guid isPermaLink="true">https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html</guid>
        
        <category>pwa</category>
        
        <category>offline</category>
        
        <category>service-worker</category>
        
        <category>jekyll</category>
        
        
      </item>
    
      <item>
        <title>create-react-pwa</title>
        <description>&lt;h1 id=&quot;tldr&quot;&gt;tl;dr&lt;/h1&gt;

&lt;p&gt;If you’d like to turn the output of &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot;&gt;progressive web app&lt;/a&gt; (PWA) with offline support, take a look at the &lt;a href=&quot;https://github.com/jeffposnick/create-react-pwa&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-pwa&lt;/code&gt;&lt;/a&gt; repo, and in particular, the &lt;a href=&quot;https://github.com/jeffposnick/create-react-pwa/compare/starting-point...pwa&quot;&gt;GitHub diff&lt;/a&gt; of the minimal changes required.&lt;/p&gt;

&lt;h1 id=&quot;create-react-app&quot;&gt;create-react-app…&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt;&lt;/a&gt; solves a problem that many folks (including I) have run into: how can you get started with a straightforward, client-rendered, single page React app and build process, without spending hours researching a list of (sometimes conflicting) dependencies to list in your &lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;? It’s a project that came out of Facebook’s React engineering a few months back, and has since gained some significant mindshare in the web developer community.&lt;/p&gt;

&lt;h1 id=&quot;and-its-limitations&quot;&gt;…and it’s limitations&lt;/h1&gt;

&lt;p&gt;In keeping with the fewer-depencies-are-better-dependencies philosophy behind &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt;, the maintainers &lt;a href=&quot;https://github.com/facebookincubator/create-react-app/issues/192&quot;&gt;appear to be vigilant&lt;/a&gt; in the fight against scope creep, and are keeping the project lean. That’s understandable, and it’s left up to end users to decide what additional functionality to layer on top of the project’s skeleton.&lt;/p&gt;

&lt;p&gt;By design, the core of the build process isn’t directly extensible. It’s kicked off by &lt;code class=&quot;highlighter-rouge&quot;&gt;npm run build&lt;/code&gt; and consists of&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;scripts&quot;: {
 &quot;build&quot;: &quot;react-scripts build&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But! The opportunity’s there to cleanly chain some additional commands after that initial &lt;code class=&quot;highlighter-rouge&quot;&gt;react-scripts build&lt;/code&gt;, while keeping the &lt;code class=&quot;highlighter-rouge&quot;&gt;react-scripts&lt;/code&gt; black box opaque, giving us the chance to modify the output of the original build process.&lt;/p&gt;

&lt;h1 id=&quot;an-opportunity-for-pwa-ification&quot;&gt;An Opportunity for PWA-ification&lt;/h1&gt;

&lt;p&gt;That gets to the heart of my investigation: what’s the easiest way to guide developers starting from a fresh &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt; towards the end goal of deploying a &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot;&gt;progressive web app&lt;/a&gt;? Specifically, what would it take to add in a &lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/service-worker/&quot;&gt;service worker&lt;/a&gt; that provided performance benefits as well as a meaningful offline experience, as well as a &lt;a href=&quot;https://developers.google.com/web/updates/2014/11/Support-for-installable-web-apps-with-webapp-manifest-in-chrome-38-for-Android&quot;&gt;web app manifest&lt;/a&gt; that contained application metadata?&lt;/p&gt;

&lt;h2 id=&quot;adding-a-web-app-manifest&quot;&gt;Adding a Web App Manifest&lt;/h2&gt;

&lt;p&gt;This is just a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;standard&lt;/a&gt; JSON file with fields containing metadata useful for controlling the “add to homescreen” experience (currently only on Android devices). While each developer needs to choose their metadata wisely, there’s nothing particularly challenging here from a technical perspective, and we just need to create the file and get it copied over to the &lt;code class=&quot;highlighter-rouge&quot;&gt;build/&lt;/code&gt; output directory as part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;npm run build&lt;/code&gt; process.&lt;/p&gt;

&lt;h2 id=&quot;adding-a-service-worker&quot;&gt;Adding a Service Worker&lt;/h2&gt;

&lt;p&gt;To handle the service worker, I (not surprisingly) turned to the &lt;a href=&quot;https://github.com/GoogleChrome/sw-precache&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sw-precache&lt;/code&gt;&lt;/a&gt; project. When added to a build process, it generates a service worker JavaScript file that will automatically version and keep all local static files—HTML, JavaScript, CSS, images, etc.—up to date. Because &lt;em&gt;all&lt;/em&gt; of the &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt; output is local static files (there’s no server-side rendering or remote API calls by default, for example), &lt;code class=&quot;highlighter-rouge&quot;&gt;sw-precache&lt;/code&gt; can handle everything we need with little configuration needed.&lt;/p&gt;

&lt;p&gt;While I’ve traditionally used &lt;code class=&quot;highlighter-rouge&quot;&gt;sw-precache&lt;/code&gt; as a JavaScript module inside of a &lt;a href=&quot;http://gulpjs.com/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp&lt;/code&gt; build&lt;/a&gt; process, it also sports a &lt;a href=&quot;https://github.com/GoogleChrome/sw-precache#command-line-interface&quot;&gt;command-line interface&lt;/a&gt;, and it’s simple to add in the &lt;code class=&quot;highlighter-rouge&quot;&gt;sw-precache&lt;/code&gt; command to the end of the &lt;code class=&quot;highlighter-rouge&quot;&gt;npm run build&lt;/code&gt; script chain.&lt;/p&gt;

&lt;h2 id=&quot;the-user-experience&quot;&gt;The User Experience&lt;/h2&gt;

&lt;p&gt;Here’s what the deployed PWA looks like on Chrome for Android, going through the steps of accepting the Add to Homescreen banner, and then launching it without a network connection.&lt;/p&gt;

&lt;iframe width=&quot;271&quot; height=&quot;480&quot; src=&quot;https://www.youtube.com/embed/nV8sKoVbD5Q?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h1 id=&quot;try-it-yourself&quot;&gt;Try it Yourself&lt;/h1&gt;

&lt;p&gt;The best way to visualize the changes to the build process, as well as the (small) modifications needed to the source code, is to view the &lt;a href=&quot;https://github.com/jeffposnick/create-react-pwa/compare/starting-point...pwa&quot;&gt;GitHub diff&lt;/a&gt; between the starting point and the “final” PWA.&lt;/p&gt;

&lt;p&gt;Take “final” with a grain of salt, because while you will end up with a build process that yields a progressive web app, there are many directions you might want to take the starter project, and some of those might entail a more complex service worker implementation. I’ve tried to cover &lt;a href=&quot;https://github.com/jeffposnick/create-react-pwa#what-additional-changes-might-be-needed&quot;&gt;some scenarios&lt;/a&gt; in the repo’s README, including &lt;a href=&quot;https://github.com/jeffposnick/create-react-pwa#ive-added-in-react-router-and-now-my-urls-dont-work-offline&quot;&gt;steps to take&lt;/a&gt; if you’re using &lt;code class=&quot;highlighter-rouge&quot;&gt;react-router&lt;/code&gt; and need arbitrary URLs to work offline, as well as how you can add in &lt;a href=&quot;https://github.com/jeffposnick/create-react-pwa#im-using-cross-origin-apis-or-resources-and-they-arent-working-while-offline&quot;&gt;runtime caching strategies&lt;/a&gt; for calls to third party APIs and resources.&lt;/p&gt;

&lt;h1 id=&quot;beyond-create-react-app&quot;&gt;Beyond create-react-app&lt;/h1&gt;

&lt;p&gt;If you’re looking for examples of PWAs build with React that go a bit beyond what  &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt; offers—for instance, that take advantage of server-side rendering or are built on third-party APIs—there are a few examples I could recommend:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/sw-precache/tree/master/app-shell-demo&quot;&gt;iFixit PWA&lt;/a&gt; (&lt;a href=&quot;https://ifixit-pwa.appspot.com/&quot;&gt;live deployment&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/insin/react-hn&quot;&gt;Hacker News PWA&lt;/a&gt; (&lt;a href=&quot;https://react-hn.appspot.com/&quot;&gt;live deployment&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 20 Aug 2016 08:00:00 -0400</pubDate>
        <link>https://jeffy.info/2016/08/20/create-react-pwa.html</link>
        <guid isPermaLink="true">https://jeffy.info/2016/08/20/create-react-pwa.html</guid>
        
        <category>pwa</category>
        
        <category>sw</category>
        
        <category>service-worker</category>
        
        <category>react</category>
        
        
      </item>
    
      <item>
        <title>Hosting Setup</title>
        <description>&lt;h1 id=&quot;blogging-software&quot;&gt;Blogging Software&lt;/h1&gt;
&lt;p&gt;I decided to go with &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;, which ships templates for blog posts, but makes it simple enough to put together standalone pages.&lt;/p&gt;

&lt;h1 id=&quot;web-hosting&quot;&gt;Web Hosting&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://help.github.com/categories/github-pages-basics/&quot;&gt;GitHub Pages&lt;/a&gt; is free, which is nice, and (obviously) has first-class support for version control.
GitHub Pages &lt;a href=&quot;https://help.github.com/articles/using-jekyll-with-pages/&quot;&gt;natively supports Jekyll&lt;/a&gt;, which means I just need to add the raw material to source control, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; content will be automatically generated.
If you don’t care about a custom domain then you can stop at this point—you can serve your site off of https://&lt;em&gt;youraccount&lt;/em&gt;.github.io. No effort required for HTTPS support!
&lt;a href=&quot;https://github.com/jeffposnick/jeffposnick.github.io&quot;&gt;jeffposnick.github.io&lt;/a&gt; is the GitHub repo with this site’s content, if you want to check out what’s going on under the hood.&lt;/p&gt;

&lt;h1 id=&quot;registering-the-domain&quot;&gt;Registering the Domain&lt;/h1&gt;
&lt;p&gt;I registered “jeffy.info” using &lt;a href=&quot;https://domains.google.com&quot;&gt;Google Domains&lt;/a&gt;.
Google Domains is in invite-only beta mode at the moment, but using an alternative domain registrar shouldn’t change the process much.
(I was surprised at how easy it was to get a &lt;code class=&quot;highlighter-rouge&quot;&gt;.info&lt;/code&gt; domain—for whatever reason, they don’t seem to be very popular. Check them out rather than settling for some obscure &lt;code class=&quot;highlighter-rouge&quot;&gt;.com&lt;/code&gt;.)&lt;/p&gt;

&lt;h1 id=&quot;add-a-cname-file-to-github&quot;&gt;Add a &lt;code class=&quot;highlighter-rouge&quot;&gt;CNAME&lt;/code&gt; file to GitHub&lt;/h1&gt;
&lt;p&gt;As per the &lt;a href=&quot;https://help.github.com/articles/adding-a-cname-file-to-your-repository/&quot;&gt;instructions&lt;/a&gt;, I added a &lt;a href=&quot;https://github.com/jeffposnick/jeffposnick.github.io/blob/master/CNAME&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CNAME&lt;/code&gt; file&lt;/a&gt; to the top-level of the repo and pushed to GitHub.&lt;/p&gt;

&lt;h1 id=&quot;cloudflare-setup&quot;&gt;CloudFlare Setup&lt;/h1&gt;
&lt;p&gt;This was my first time using CloudFlare, so I needed to set up a (free) account.
I told CloudFlare that I wanted it to take control over the “jeffy.info” domain, and I set up two &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; records for the bare (“apex”) domain “jeffy.info” to resolve to the &lt;a href=&quot;https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider/&quot;&gt;two published IP addresses&lt;/a&gt; for GitHub’s servers.
I also set up a &lt;code class=&quot;highlighter-rouge&quot;&gt;CNAME&lt;/code&gt; record for “www” as an alias of “jeffposnick.github.io”, so that “www.jeffy.info” will resolve.
&lt;img src=&quot;/assets/images/cloudflare_dns_settings.png&quot; alt=&quot;CloudFlare settings screenshot&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;changing-the-google-domains-dns-settings&quot;&gt;Changing the Google Domains DNS Settings&lt;/h1&gt;
&lt;p&gt;In order for CloudFlare to start serving traffic for “jeffy.info”, I needed to change the authoritative DNS settings for the domain to point to CloudFlare’s severs.
This was straight forward with the Google Domains UI (refer to your registrar’s online help if you’re using something else):
&lt;img src=&quot;/assets/images/google_domains_custom_dns.png&quot; alt=&quot;Google Domains custom DNS settings&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;https-only-setup&quot;&gt;HTTPS-only Setup&lt;/h1&gt;
&lt;p&gt;CloudFlare auto-provisioned a certificate for “jeffy.info” withing a couple of minutes, which was awesome and as painless as promised.
Make sure you use the “Flexible SSL” option, which is required to work with a GitHub Pages backend server.
Using “Flexible SSL” means that the GitHub Pages ⇔ CloudFlare traffic isn’t encrypted, but the CloudFlare ⇔ user’s browser traffic is.
That’s sufficient for my goal of enabling web functionality that requires HTTPS to the end user’s browser, but it’s probably not a good idea if you’re concerned about traffic vulnerabilities in the GitHub Pages ⇔ CloudFlare hop.
I want to make sure that my blog is HTTPS-only, and &lt;a href=&quot;https://support.cloudflare.com/hc/en-us/sections/200038236-Page-Rules&quot;&gt;CloudFlare’s page rules&lt;/a&gt; interface allowed me to set that up:
&lt;img src=&quot;/assets/images/cloudflare_page_rules.png&quot; alt=&quot;HTTPS-only via CloudFlare's page rules&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;optimizing-content&quot;&gt;Optimizing Content&lt;/h1&gt;
&lt;p&gt;Since CloudFlare is a full-fledged CDN, they offer a number of content optimization options. In general, I turned off most of the settings, but I did enable HTML + JS + CSS minification:
&lt;img src=&quot;/assets/images/cloudflare_auto_minify.png&quot; alt=&quot;CloudFlare's web optimization settings&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Since I’m relying on GitHub Pages to do my Jekyll’s &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; build, it seemed easiest to just let CloudFlare handle the minification rather than trying to work out a scripted solution.&lt;/p&gt;

&lt;p&gt;CloudFlare offers image minification as well, but only as part of their paid offering. So I’m using &lt;a href=&quot;https://www.npmjs.org/package/gulp-imagemin&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp-imagemin&lt;/code&gt;&lt;/a&gt; locally on all my images, and pointing to the minified versions in posts. Be sure to minify your images!&lt;/p&gt;

&lt;h1 id=&quot;future-tweaks&quot;&gt;Future Tweaks&lt;/h1&gt;
&lt;p&gt;I’m not particularly happy with the default Jekyll templates, and have already made a few changes.
I’m sure there will be lots of twiddling with that to come.
I’m also not particularly familiar with the best practices for a build workflow. I’ve got a basic &lt;a href=&quot;https://github.com/jeffposnick/jeffposnick.github.io/blob/master/gulpfile.js&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulpfile.js&lt;/code&gt;&lt;/a&gt; that I’m sure will grow over time.&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Nov 2014 08:34:34 -0500</pubDate>
        <link>https://jeffy.info/2014/11/28/hosting-setup.html</link>
        <guid isPermaLink="true">https://jeffy.info/2014/11/28/hosting-setup.html</guid>
        
        <category>meta</category>
        
        <category>https</category>
        
        <category>cloudflare</category>
        
        <category>gh-pages</category>
        
        <category>github</category>
        
        <category>hosting</category>
        
        
      </item>
    
      <item>
        <title>thirty-four on the Web (Again)</title>
        <description>&lt;h1 id=&quot;about-me&quot;&gt;About Me&lt;/h1&gt;
&lt;p&gt;I’m &lt;a href=&quot;https://twitter.com/jeffposnick&quot;&gt;Jeff Posnick&lt;/a&gt;.
I’ve been working on the &lt;a href=&quot;https://developers.google.com/careers/&quot;&gt;Developer Relations&lt;/a&gt; team at Google NYC since 2007, first on the &lt;a href=&quot;https://developers.google.com/adwords/api/&quot;&gt;Ads APIs&lt;/a&gt;, then &lt;a href=&quot;https://developers.google.com/youtube/&quot;&gt;YouTube&lt;/a&gt;, and currently on the &lt;a href=&quot;http://www.webplatform.org/&quot;&gt;Open Web Platform&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;about-this-blog&quot;&gt;About this Blog&lt;/h1&gt;
&lt;p&gt;I’ve been blogging &lt;a href=&quot;http://thirtyfour.blogspot.com/&quot;&gt;elsewhere&lt;/a&gt; since 2003.
The other 34 started out using &lt;a href=&quot;http://en.wikipedia.org/wiki/Blosxom&quot;&gt;Blosxom&lt;/a&gt; on a self-hosted web server.
I moved it over to Blogger eventually.&lt;/p&gt;

&lt;p&gt;I’m going to keep &lt;a href=&quot;http://thirtyfour.blogspot.com/&quot;&gt;34&lt;/a&gt; around for personal topics.
This blog, &lt;a href=&quot;https://jeffy.info/&quot;&gt;thirty-four&lt;/a&gt;, is going to focus on web technologies.
Serving it via HTTPS, and having full control over the HTML/JavaScript/CSS, means that I’ll be able to take advantage of some of the new features being added to the web platform, like those powered by &lt;a href=&quot;https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html&quot;&gt;service workers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Stay tuned for a post detailing this blog’s setup (spoiler alert: it’s a &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; site hosted on &lt;a href=&quot;https://help.github.com/categories/github-pages-basics/&quot;&gt;GitHub pages&lt;/a&gt;, with the &lt;a href=&quot;https://www.cloudflare.com/&quot;&gt;CloudFlare CDN&lt;/a&gt; providing &lt;a href=&quot;http://blog.cloudflare.com/easiest-ssl-ever-now-included-automatically-w/&quot;&gt;HTTPS support&lt;/a&gt;.)&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Nov 2014 05:34:34 -0500</pubDate>
        <link>https://jeffy.info/2014/11/28/thirty-four-on-the-web-again.html</link>
        <guid isPermaLink="true">https://jeffy.info/2014/11/28/thirty-four-on-the-web-again.html</guid>
        
        <category>meta</category>
        
        
      </item>
    
  </channel>
</rss>
