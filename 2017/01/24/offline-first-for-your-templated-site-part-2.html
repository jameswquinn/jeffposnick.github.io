<!doctype html>
<html lang="en" itemscope itemtype="http://schema.org/Blog">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="manifest" href="/manifest.json">
  <link rel="icon" sizes="192x192" href="/assets/images/34.png">

  <link rel="canonical" href="http://localhost:4000/2017/01/24/offline-first-for-your-templated-site-part-2.html">
  <meta property="og:url" content="http://localhost:4000/2017/01/24/offline-first-for-your-templated-site-part-2.html">
  <link rel="alternate" type="application/atom+xml" title="thirty-four, a blog" href="/feed.xml">

  <title>Offline-first for Your Templated Site (Part Two)</title>
  <meta property="og:title" content="Offline-first for Your Templated Site (Part Two)">
  <meta name="description" content="Full-page caching vs. App Shell vs. service worker rendering.">
  <meta property="og:description" content="Full-page caching vs. App Shell vs. service worker rendering.">
  <meta property="og:site_name" content="thirty-four">
  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2017-01-24 22:00:00 +0000">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@jeffposnick">

  <meta name="theme-color" content="#00bcd4">
  <style>
  body {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
    margin: 1em 5em 1em 5em;
    padding: 0;
    color: #2d2d2d;
    background-color: #f9f9f9;
  }

  @media (max-width: 600px) {
    body {
      margin: 1em;
    }
  }

  code {
    font-family: "Source Code Pro", Monaco, monospace;
  }

  pre {
    border: 2px dotted #cecece;
    padding: 1em;
  }

  a {
    color: #00659d;
    text-decoration: none;
  }

  .site-header {
    font-family: "Source Code Pro", Monaco, monospace;
    font-size: 2em;
    font-style: italic;
    margin: 1em;
    text-align: right;
  }

  .site-header > a {
    color: #2d2d2d;
  }

  .post-list {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .post-list > li {
    border: 2px dotted #cecece;
    border-radius: 0.5em;
    margin: 1em;
    padding: 1em;
  }

  .post-header > a {
    color: #2d2d2d;
  }

  .post-meta {
    font-size: 0.9em;
    font-style: italic;
    margin-top: -1em;
    margin-bottom: 3em;
  }

  article a {
    border-bottom: 1px dotted #00659d;
  }

  article > p > img {
    max-width: 534px;
  }

  .youtube-embed {
    height: 300px;
    max-width: 100%;
    width: 534px;
  }

  .site-footer {
    margin-top: 3em;
    border-top: 1px dotted #cecece;
    display: flex;
    flex-direction: row;
  }

  .site-footer > div {
    margin: 1em;
  }

  .site-footer > div > div {
    margin-bottom: 0.5em;
  }

  .site-footer > .links {
    flex-basis: 30%;
  }

  .site-footer > .text {
    flex-basis: 70%;
  }

  .icon > svg {
    display: inline-block;
    width: 16px;
    height: 16px;
    vertical-align: middle;
  }
</style>

</head>

  <body>
    <div class="site-header">
  <a href="/">thirty-four, a blog</a>
</div>

    <div class="page-content">
      <div class="wrapper">
        <main>
  <header>
    <h1 class="post-header"><a href="">Offline-first for Your Templated Site (Part Two)</a></h1>
    <p class="post-meta">Jan 24, 2017</p>
  </header>
  <article>
    <p><em>This is the second part of a planned three-part series.</em></p>

<p><em>Part <a href="https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html">one</a> covered some basic terminology an setup that’s referenced throughout this post.</em></p>

<p><em>Part three will dive into a specific service worker implementation that can be
used to provide an offline-first experience for a Jekyll-based site.</em></p>

<p><em>Folks who can’t wait for part three are welcome to check out the
<a href="https://jeffy.info">https://jeffy.info</a>
service worker <a href="https://github.com/jeffposnick/jeffposnick.github.io/tree/work/src">implementation</a>
ahead of time.</em></p>

<h1 id="decisions-decisions">Decisions, decisions</h1>

<p>With those preliminary definitions out of the way, we can focus on the question at hand: how do you provide an offline-first experience for your templated site?</p>

<p>I’m going to outline three different approaches, each with their own benefits and drawbacks. Choosing the right approach requires balancing various tradeoffs, and the aim of this post is to walk through the plusses and minuses of each strategies, so that you can make an informed decision about what works best for your site.</p>

<h1 id="option-1-cache-entire-html-documents">Option 1: Cache entire HTML documents</h1>

<h2 id="how-it-works">How it works</h2>

<p>This approach uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage">Cache Storage API</a> to keep a copy of the fully rendered HTML document that corresponds to each URL. The documents might be precached when the service worker is installed, or the caches might be populated via a runtime caching strategy that adds to the cache as users browse from page to page.</p>

<h2 id="benefits">Benefits</h2>

<h3 id="service-worker-simplicity">Service worker simplicity</h3>

<p>The service worker needed to implement this type of strategy is <em>relatively</em> straightforward. The <code class="highlighter-rouge">fetch</code> handler can check to see whether <code class="highlighter-rouge">event.request.mode === 'navigate'</code>, and if so, use a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate">stale-while-revalidate strategy</a> to handle the request for the HTML document.</p>

<h3 id="minimal-additional-maintenance">Minimal additional maintenance</h3>

<p>While you need to create and deploy a service worker script, there isn’t anything additional that you need to deploy and maintain. The same HTML documents that you’ve previously generated and deployed can continue to be served the same way.</p>

<h3 id="multiple-layout-template-flexibility">Multiple layout template flexibility</h3>

<p>Instead of a single layout template, some sites might find themselves using multiple layouts to generate the final HTML. For example, all documents served from the URL prefix <code class="highlighter-rouge">/blog/</code> might use <code class="highlighter-rouge">blog_layout.tmpl</code>, while all documents served from under <code class="highlighter-rouge">/news/</code> might use <code class="highlighter-rouge">news_layout.tmpl</code>.</p>

<p>Because the complete HTML documents are stored and retrieved from the cache, the service worker doesn’t need any special knowledge about which underlying layout was used to generate the page.</p>

<p>That also means that a subset of URLs that aren’t generated via templating at all—perhaps a site’s <code class="highlighter-rouge">about.html</code> page, for instance—can be handled via the same logic used for all the other URLs.</p>

<h2 id="drawbacks">Drawbacks</h2>

<h3 id="cache-overhead">Cache overhead</h3>

<p>Let’s return to our diagram of the “<a href="https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html#the-process-that-smushes-together-the-templates-and-the-contents-and-outputs-a-final-html-document">smushening</a>” process, which takes our template, combines it with each of our individual content files, and then results in a complete HTML document:</p>

<p><img src="/assets/images/2016-11-02/smushening.svg" alt="A layout + content = final pages" class="half-width" /></p>

<p>The <code class="highlighter-rouge">blog_layout.tmpl</code> file is used to generate each of the final HTML documents, and that means that the size of each HTML file is roughly equal to the size of the template file plus the size of the page-specific content.</p>

<p>If your template file is <code class="highlighter-rouge">X</code> bytes, and your have <code class="highlighter-rouge">N</code> output HTML files, you’re incurring <code class="highlighter-rouge">X * N</code> bytes of duplicated cache contents, due to size of the templated portion of each final HTML document.</p>

<p>If <code class="highlighter-rouge">X</code> is a fairly small number (a template file of less than 1kb is common) and/or <code class="highlighter-rouge">N</code> is small (say, only a few dozen unique HTML files), then the amount of cache storage used is negligible. However, if you’re using larger templates, or you know that you have hundreds or even thousands of HTML pages that a user might have cached, the overhead can start impacting those users who are storage constrained.</p>

<h3 id="messy-updates">Messy updates</h3>

<p>While the cache overhead isn’t a showstopper, the compromises involved in updating previously cached content is more of a concern. Let’s assume that we have <code class="highlighter-rouge">foo.html</code>, <code class="highlighter-rouge">bar.html</code>, and <code class="highlighter-rouge">foo_bar.html</code> HTML files stored in our cache.</p>

<p>If we were to make some updates to the <code class="highlighter-rouge">foo.md</code> content that’s used to populate <code class="highlighter-rouge">foo.html</code>, our update strategy is to ensure that <code class="highlighter-rouge">foo.html</code> eventually gets refetched from the network. This might happen via a normal <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate">stale-while-revalidate</a> flow, in which case the new content will only be available the <em>second</em> time a user revisits the page. Or it might happen by explicitly purging the existing <code class="highlighter-rouge">foo.html</code> entry from the cache ahead of time, making the new content available for the <em>next</em> visit.</p>

<p>But what if we make an update to <code class="highlighter-rouge">blog_layout.tmpl</code>? Maybe we’ve changed our navigation bar, or updated some header text. The impact of this change ripples beyond a single cache entry—<em>all</em> of our cached HTML files that depended on <code class="highlighter-rouge">blog_layout.tmpl</code> are now out of date.</p>

<p>We have the same options for dealing with this as before: let a stale-while-revalidate caching strategy gradually update the stale entries as users revisit pages, or proactively purge the out of date cache content, which in this case could mean invalidating our entire cache. There are serious downsides to each approach, though.</p>

<p>If we rely on a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate">stale-while-revalidate</a> runtime caching strategy to gradually update our cache, users will see inconsistencies across page navigations. The changes made to <code class="highlighter-rouge">blog_layout.tmpl</code> will only take effect after they revisit pages multiple times. If a user returns to a previously cached page months later, they’ll still see your old layout, which can be jarring after they’ve gotten accustomed to seeing layout changes on fresh pages.</p>

<p>To avoid jarring your users, proactively purging <em>all</em> cached HTML that relies on a modified template is arguably the best approach. But now you’re faced with another tradeoff: the performance and offline benefits of caching are diminished if users’ caches are invalidated frequently. The effort that you put into implementing a caching strategy is wasted if you have to throw your entire cache away due to even small updates to your site’s layout.</p>

<h2 id="real-world-examples">Real-world examples</h2>

<p>A number of my colleagues, including <a href="https://gauntface.com/blog/">Matt Gaunt</a>, <a href="https://paul.kinlan.me">Paul Kinlan</a>, and <a href="https://sgom.es/">Sérgio Gomes</a>, are using this option for their blogs.</p>

<h1 id="option-2-use-an-application-shell-architecture">Option 2: Use an Application Shell architecture</h1>

<h2 id="how-it-works-1">How it works</h2>

<p>The Application Shell architecture is covered in great detail in <a href="https://developers.google.com/web/fundamentals/architecture/app-shell">this article</a> by Addy Osmani and Matt Gaunt. My talk from the 2015 Chrome Dev Summit also covers similar ground, for those who prefer video:</p>

<iframe class="youtube-embed" src="https://www.youtube.com/embed/jCKZDTtUA2A" allowfullscreen="" frameborder="0"></iframe>

<p>While the Application Shell architecture is often talked about in reference to “web apps,” it’s definitely applicable to the types of templated “content sites” that we’re talking about here.</p>

<p>The general approach is to repurpose your existing page structure, i.e. what’s defined in your <code class="highlighter-rouge">blog_layout.tmpl</code> template, to serve as your Application Shell. This should be a valid, standalone HTML file (let’s call it <code class="highlighter-rouge">shell.html</code>) that includes a placeholder element that the dynamic content gets inserted into at runtime, via client-side templating.</p>

<p>The dynamic content could be the same raw content sources—<code class="highlighter-rouge">foo.md</code>, <code class="highlighter-rouge">bar.md</code>, etc.—in which case the Application Shell’s JavaScript would need to <a href="https://github.com/markdown-it/markdown-it">convert</a> the content to HTML at runtime, prior to inserting it into the DOM. Or you might go through an additional step and convert the raw content into HTML snippets via a server-side process, in which case the content snippets can be inserted directly into the DOM at runtime.</p>

<p>You can use either a precaching or a runtime caching strategy like <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate">stale-while-revalidate</a> to keep both <code class="highlighter-rouge">shell.html</code> and the underlying content up to date, while still serving them cache-first.</p>

<h2 id="benefits-1">Benefits</h2>

<h3 id="clean-updates">Clean updates</h3>

<p>Your structural HTML (<code class="highlighter-rouge">shell.html</code>) and your content are cached independently, so when you make changes to a page’s content or to your site’s layout elements, cache invalidation is simple and efficient. The only cache entries that need to be updated is either the content itself, or the entry for <code class="highlighter-rouge">shell.html</code>. If <code class="highlighter-rouge">shell.html</code> does get updated, then the updates will immediately apply to all pages on your site that share that Application Shell, ensuring that your site looks the same as the user moves from page to page. You eliminate the risk of a months-old cached page being shown, jarring a user with an inconsistent layout.</p>

<h3 id="low-overhead-precaching">Low-overhead precaching</h3>

<p>Using this architecture opens the door to precaching more of your site’s content. Larger precache coverage means that pages a user hasn’t previously navigated to will still work offline and load quickly. There are two reasons why aggressive precaching is more viable:</p>

<p>First, each piece of content can be cached as-is, independent of the App Shell’s HTML. The <a href="#cache-overhead">cache overhead</a> concerns with full-page caching don’t apply, and as a developer, you don’t have to worry about wasting as much bandwidth and space as you would if you were precaching full HTML documents.</p>

<p>Second, and more importantly, <a href="#clean-updates">clean updates</a> mean that you’re much less likely to end up throwing away data once it’s been precached. The only time you’d have to expire and redownload precached content is if that specific content is updated. A substantial precache payload is makes much less sense if you know that it will all end up expired each time you tweak your site’s template.</p>

<h2 id="drawbacks-1">Drawbacks</h2>

<h3 id="routing-logic-in-your-service-worker">Routing logic in your service worker</h3>

<p>In the Application Shell model, your service worker needs to have special logic in place to handle <a href="https://html.spec.whatwg.org/#navigating-across-documents">navigation requests</a>. While the incoming request might be for a URL like <code class="highlighter-rouge">https://example.com/2016/12/foo.html</code>, your service worker needs to respond with your cached <code class="highlighter-rouge">shell.html</code> document, not with <code class="highlighter-rouge">foo.html</code> (which won’t be cached in this model). Your Application Shell is then responsible for performing client-side templating and inserting the correct content into the DOM, based on whatever the request URL is.</p>

<p>This works fine when you only have one common layout, defined in <code class="highlighter-rouge">shell.html</code>, that’s shared by all the pages on your site. But if there’s a subset of pages on your site that use completely different layouts, like <code class="highlighter-rouge">https://example.com/about.html</code>, your service worker needs to know <em>not</em> to respond to those navigation requests with <code class="highlighter-rouge">shell.html</code>.</p>

<p>Your service worker is now an HTTP router, examining incoming navigations requests and serving the right type of response for each URL. If there’s a simple URL pattern that can be used to match all of the requests that can be handled with the <code class="highlighter-rouge">shell.html</code> layout, then you’re in good shape—something like the following might suffice:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>self.addEventListener('fetch', event =&gt; {
  const yearMonthPrefix = new RegExp('/\d{4}/\d{2}/');
  if (event.request.mode === 'navigation') {
    if (event.request.url.matches(yearMonthPrefix)) {
      // Use the Application Shell to handle requests like
      // https://example.com/2016/12/foo.html
      event.respondWith(caches.match('shell.html'));
    } else {
      // Use an appropriate runtime caching strategy, like
      // stale-while-revalidate, to handle requests like
      // https://example.com/about.html.
    }
  } else {
    // Use an appropriate runtime caching strategy for
    // non-navigation requests, like requests for
    // images or other resources.
  }
});
</code></pre>
</div>

<p>But if you don’t have that level of consistency in your URL structure, of if there’s a subset of pages that fall under the <code class="highlighter-rouge">/year/month/</code> prefix but use a completely different template, accurately reflecting that routing logic in your service worker gets much trickier and you need to construct a bespoke solution.</p>

<h3 id="duplicated-effort">Duplicated effort</h3>

<p>If you’ve already got a templated site, adopting the Application Shell architecture will usually mean duplicating pieces of your existing infrastructure. You need to take your <code class="highlighter-rouge">blog_layout.tmpl</code> and convert it into a <code class="highlighter-rouge">shell.html</code> file, adding to it the necessary client-side templating logic to populate your shell.</p>

<p>You might also need to add in a build step that takes original Markdown sources and converts them to HTML snippets, in in lieu of having to perform that Markdown conversion inside your Application Shell.</p>

<p>Finally, if your site relies on any sort of custom routing or templating rules that are implemented server-side, that routing logic needs to be moved into your service worker, as explained in the <a href="#routing-logic-in-your-service-worker">previous section</a>.</p>

<p>This duplication means that there are more opportunities for pieces of your site to get out of sync. If you make changes to your <code class="highlighter-rouge">blog_layout.tmpl</code>, but the corresponding changes aren’t made to <code class="highlighter-rouge">shell.html</code>, then browsers which lack service worker support will see one thing, while browsers that have a service worker responding with your Application Shell will see something else. Similar issues could arise if your routing rules need tweaking—they could potentially need to be changed in <em>three</em> places (server-side, client-side in <a href="https://en.wikipedia.org/wiki/Single-page_application">SPA-style</a> JavaScript, and client-side in service worker JavaScript) depending on how complicated your routing needs are. Trisomorphic routing: it’s actually A Thing!</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/adactioJournal">@adactioJournal</a> Shows there are fantastic opportunities, though. I&#39;ve yet to see someone nail &quot;trisomorphic&quot; routing (server + JS + SW).</p>&mdash; Nolan Lawson (@nolanlawson) <a href="https://twitter.com/nolanlawson/status/735469605238509569">May 25, 2016</a></blockquote>

<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Proper automation of your build process can ensure that the overhead and risk of duplicated pieces getting out of sync is minimal, but that’s one more thing to keep track of.</p>

<h2 id="real-world-examples-1">Real-world examples</h2>

<p>The <a href="https://ifixit-pwa.appspot.com/">iFixit PWA</a> sample (the <a href="https://github.com/GoogleChrome/sw-precache/tree/master/app-shell-demo">source</a> of which is part of the <a href="https://github.com/GoogleChrome/sw-precache">sw-precache project</a>) is an Application Shell populated with dynamic content from the <a href="https://www.ifixit.com/api/2.0/doc/">iFixit API</a>.</p>

<h1 id="option-3-service-worker-templating">Option 3: Service worker templating</h1>

<h2 id="how-it-works-2">How it works</h2>

<p>With this approach, you take the logic needed to smush together your templates and content and implement it within your service worker.</p>

<p>This doesn’t mean that you’d do away with your site’s existing build process, though. You can’t assume that when a user visits your site there’s going to be an active service worker, so you still need to serve complete HTML pages via your normal web server. But when a user returns to your site using a browser that supports service workers, they no longer have to request those complete HTML pages in order to display your site. They should already have your site’s templates cached, and they may or may not have the page’s content cached as well. So, at worst, only a very minimal amount of page-specific content needs to be requested, and at best, your service worker can assemble the complete HTML immediately, without having to go to the network at all.</p>

<h2 id="benefits-2">Benefits</h2>

<h3 id="clean-updates-and-low-overhead-precaching">Clean updates and low-overhead precaching</h3>

<p>Both the <a href="#clean-updates">clean updates</a> and <a href="#low-overhead-precaching">low-overhead precaching</a> benefits of the App Shell model apply here, as well.</p>

<h3 id="no-need-to-adopt-single-page-app-patterns">No need to adopt Single Page App patterns</h3>

<p>While the App Shell approach might seem familiar to developers who are familiar with writing client-side JavaScript and using the <a href="https://en.wikipedia.org/wiki/Single-page_application">Single Page App</a> (SPA) pattern, not every developer who manages a templated site with be comfortable with that model. You don’t have to write and deploy a SPA when you use the service worker templating option, but you end up with most of the same benefits.</p>

<p>(Of course, there’s a significant engineering effort required to properly implement service worker templating, but it’s a different kind of effort…)</p>

<h2 id="drawbacks-2">Drawbacks</h2>

<h3 id="a-javascript-friendly-templating-system-is-a-must">A JavaScript-friendly templating system is a must</h3>

<p>This approach is only viable if you’re using a templating system that has a JavaScript implementation. And because the code will be run inside of a service worker, JavaScript code that requires features specific to the node environment, like filesystem support, won’t work.</p>

<p>Fortunately, the JavaScript ecosystem is vibrant, and there’s a decent chance that you’d <a href="https://npms.io/search?q=template">find</a> a JavaScript implementation of many templating systems. Running the JavaScript code through <a href="https://github.com/substack/node-browserify">browserify</a> can often smooth over the differences between the node and service worker runtime environments.</p>

<h3 id="heavyweight-service-worker-code">Heavyweight service worker code</h3>

<p>In order to get your templating system working inside of your service worker, you’ll almost certainly need to bundle in a number of external dependencies. Compared to a svelte service worker that implements a basic runtime caching strategy, you’ll need to transfer more bytes of JavaScript each time your service worker is fetched from the network.</p>

<p>Your service worker is almost certainly going to spend more time executing code, since the “<a href="https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html#the-process-that-smushes-together-the-templates-and-the-contents-and-outputs-a-final-html-document">smushening</a>” process that would otherwise be done at build-time is effectively run within a user’s browser each time it display a page. The amount of overhead that this adds depends on how efficient your JavaScript templating system is and how powerful each of your users’ devices are.</p>

<h3 id="routing-logic-in-your-service-worker-1">Routing logic in your service worker</h3>

<p>This was covered in detail in the App Shell’s drawbacks section; the same routing considerations apply here. The main difference is that instead of serving a cached <code class="highlighter-rouge">shell.html</code> file when the route matches, you need to kick off your templating logic when there’s a matching navigation request.</p>

<h3 id="duplicated-effort-1">Duplicated effort</h3>

<p>This is also similar to the drawback with using an App Shell. Using this approach requires that you continue to run the “<a href="https://jeffy.info/2016/11/02/offline-first-for-your-templated-site-part-1.html#the-process-that-smushes-together-the-templates-and-the-contents-and-outputs-a-final-html-document">smushening</a>” process like you were previously doing, but then additionally start serving not only the final HTML documents, but also the unprocessed template and content files, since those pieces will need to be fetched and cached by the service worker. You’ll need to make sure that whenever a template or content is updated, both the final HTML as well as the raw files are updated on your server.</p>

<p>You’ll also probably end up duplicating some of the work that your current build process does to generate metadata about your site. For example, Jekyll maintains it own list of recent posts and uses it to populate the index page for a site. Your service worker needs similar data in order to construct the same page, so writing your own code to <a href="https://github.com/jeffposnick/jeffposnick.github.io/blob/work/gulpfile.js#L34">generate</a> the metadata in a <a href="https://raw.githubusercontent.com/jeffposnick/jeffposnick.github.io/master/posts.json">format</a> that your service worker could consume, and keeping that metadata in sync whenever you update your site, is now required.</p>

<h2 id="real-world-examples-2">Real-world examples</h2>

<p>My personal blog, <a href="https://jeffy.info/">https://jeffy.info/</a>, is currently using <a href="https://github.com/jeffposnick/jeffposnick.github.io/tree/work/src">service worker templating</a>. We’ll dive into the specifics of how that’s implemented in the next part of this series!</p>

  </article>
</main>

      </div>
    </div>
    <footer class="site-footer">
  <div class="links">
    <div><a href="mailto:blog@posnick.org">blog@posnick.org</a></div>
    <div>
      <a href="https://github.com/jeffposnick">
          <span class="icon  icon--github">
            <svg viewBox="0 0 16 16">
              <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
            </svg>
          </span>
        <span class="username">jeffposnick</span>
      </a>
    </div>
    <div>
      <a href="https://twitter.com/jeffposnick">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>
        <span class="username">jeffposnick</span>
      </a>
    </div>
  </div>
  <div class="text">
    <div>thirty-four is crafted with love in Brooklyn, by Jeff Posnick.</div>
    <div class="license">
  This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</div>

  </div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-57130145-1', 'auto');
  ga('send', 'pageview');
</script>


    <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('/service-worker.js');
    });
  }
</script>

  </body>
</html>
